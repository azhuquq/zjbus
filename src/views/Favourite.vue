<template>
    <div>
        <v-app-bar elevation="1">
            <v-app-bar-title>Êî∂ËóèË∑ØÁ∫ø</v-app-bar-title>
            <template v-slot:append>
                <div v-if="!isLocationLoaded && favourites.length != 0">
                    <v-btn icon="ri:map-pin-line" @click="requestLocation()"></v-btn>
                </div>

                <div v-if="isRefreshingStat" class="me-2">
                    <v-progress-circular indeterminate />
                </div>
                <div v-else>
                    <v-btn icon="ri:refresh-line" @click="refresh"></v-btn>
                </div>
            </template>
        </v-app-bar>
        <div v-if="favourites.length === 0">
            <v-empty-state icon="ri:bookmark-line" title="Êó†Êî∂ËóèË∑ØÁ∫ø">
                <template v-slot:text>
                    <div class="align-center">
                        ÊÇ®ÂèØ‰ª•ÁÇπÂáªË∑ØÁ∫øËØ¶ÊÉÖÁöÑÂè≥‰∏äËßí<v-icon>ri:star-s-line</v-icon>ËøõË°åÊî∂Ëóè
                    </div>
                </template>
            </v-empty-state>
        </div>
        <!-- ‰∏äÈù¢ÁöÑ‰∏çÁî®Êîπ -->
        <div v-else class="flex flex-col gap-2">
            <!-- Â¶ÇÊûú‰ªª‰∏ÄÁ∫øË∑ØËØ∑Ê±ÇÂ§±Ë¥•ÔºåÊòæÁ§∫ÁΩëÁªúÈîôËØØÁªÑ‰ª∂ -->
            <NetworkErr v-if="hasErrorStat" />
            <v-card v-for="(item, index) in mergedFavourites" :key="index">
                <template v-slot:title>
                    <div class="text-xl font-bold">
                        {{ item.routename }}
                    </div>
                </template>
                <div class="font-bold text-lg">
                    <v-card v-for="(per, index) in item.directions" :key="index" @click="goToRouteDetail(per)"
                        variant="flat" :title="per.laststation">
                        <template v-slot:title>
                            <div class="text-lg font-bold flex flex-row justify-between align-center">
                                <div>
                                    ÂºÄÂæÄ {{ per.laststation }}
                                </div>
                                <v-icon>ri:navigation-line</v-icon>
                            </div>
                        </template>
                        <template v-slot:subtitle v-if="per.nearestStop">
                            {{
                                `Á¶ªÊÇ®ÊúÄËøëÔºö${per.nearestStop.stationNo} ${per.nearestStop.stationName}`
                            }}
                        </template>

                        <v-card-text>
                            <!-- ÂàùÂßãÂåñÊ†áÂøóÂèòÈáèÔºåÈªòËÆ§Ê≤°ÊúâÊ¥ªÂä®ËΩ¶ËæÜ -->
                            <template v-if="item.isLoaded">
                                <div v-if="item.status && item.status.length > 0">
                                    <template v-if="hasActiveBuses(item.status, per.dir)">
                                        <!-- ÊúâÊ¥ªÂä®ËΩ¶ËæÜÊó∂ -->
                                        <div class="flex flex-row overflow-x-auto whitespace-nowrap">
                                            <div v-for="(bus, index) in item.status" :key="index">
                                                <div v-if="bus.roadstatus && bus.roadstatus === per.dir">
                                                    <v-chip class="p-2 me-2" color="green" label>
                                                        <v-icon icon="ri:bus-line" start />
                                                        {{ `${fixNo(bus.stationno)} ${bus.sitename}
                                                        ${fixSpeed(bus.speed)} km/h` }}
                                                    </v-chip>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <template v-else>
                                        <!-- ÂΩìÂâçÊñπÂêëÊ≤°ÊúâÊ¥ªÂä®ËΩ¶ËæÜ -->
                                        <v-chip class="p-2" label color="primary">
                                            <v-icon icon="ri:signpost-line" start />
                                            Êó†Ê¥ªÂä®ËΩ¶ËæÜ
                                        </v-chip>
                                    </template>
                                </div>
                                <div v-else>
                                    <!-- ÂΩìÂâçÁ∫øË∑ØÊ≤°ÊúâÁä∂ÊÄÅ -->
                                    <v-chip class="p-2" label color="primary">
                                        <v-icon icon="ri:signpost-line" start />
                                        Êó†Ê¥ªÂä®ËΩ¶ËæÜ
                                    </v-chip>
                                </div>
                            </template>
                            <div v-else>
                                <!-- Êú™Âä†ËΩΩÂÆåÊàêÊó∂ÊòæÁ§∫Êú™Áü• -->
                                <v-chip class="p-2" label>
                                    <v-icon icon="ri:questionnaire-line" start />
                                    Êú™Áü•
                                </v-chip>
                            </div>
                        </v-card-text>
                    </v-card>
                </div>
            </v-card>
        </div>
    </div>
</template>

<script>
import { getBusLiveStatus } from '@/api/wechatApi'
import NetworkErr from '@/components/NetworkErr.vue'
export default {
    name: 'Favourite',
    components: { NetworkErr },
    data() {
        return {
            favourites: [], // Áî®‰∫éÂ≠òÂÇ®Êî∂ËóèÁöÑÁ∫øË∑Ø‰ø°ÊÅØ
            mergedFavourites: [], // Â≠òÂÇ®ÂêàÂπ∂ÂêéÁöÑÊî∂ËóèË∑ØÁ∫ø
            firstLoad: true, // Ê†áÂøóÂà§Êñ≠ÊòØÂê¶È¶ñÊ¨°Âä†ËΩΩ
            isRefreshing: false, // Ê†áÂøóÊòØÂê¶Ê≠£Âú®Âà∑Êñ∞
            hasError: false, // Ê†áÂøóÊòØÂê¶ÊúâÁΩëÁªúÈîôËØØ
            favouritesSnapshot: null,
            timers: [],
            isLocationLoaded: false,
            locationTimer: null,
        }
    },
    computed: {
        isRefreshingStat() {
            // Ê£ÄÊü• mergedFavourites ‰∏≠ÊòØÂê¶Êúâ‰ªª‰ΩïÈ°πÁõÆÊ≠£Âú®Âà∑Êñ∞
            return this.mergedFavourites.some(fav => fav.isRefreshing)
        },
        hasErrorStat() {
            // Ê£ÄÊü• mergedFavourites ‰∏≠ÊòØÂê¶Êúâ‰ªª‰ΩïÈ°π ÁõÆÂá∫Áé∞ÈîôËØØ
            return this.mergedFavourites.some(fav => fav.isError)
        }
    },
    mounted() {
        // ‰ªé localStorage ‰∏≠ËØªÂèñÊî∂ËóèÁöÑÁ∫øË∑ØÔºåÂπ∂ËøõË°åÂêàÂπ∂
        this.favourites = JSON.parse(localStorage.getItem('stored_data_favouriteRoutes')) || []
        this.mergeFavourites() // ÂàùÂßãÂåñÂêàÂπ∂Êî∂ËóèË∑ØÁ∫ø
        this.favouritesSnapshot = JSON.stringify(this.favourites) // ‰øùÂ≠òÊî∂ËóèÂàóË°®Âø´ÁÖß
        this.refresh() // ÂàùÊ¨°Âä†ËΩΩÊó∂Ëá™Âä®Âà∑Êñ∞
    },
    activated() {
        const currentFavourites = JSON.parse(localStorage.getItem('stored_data_favouriteRoutes')) || []
        if (JSON.stringify(currentFavourites) !== JSON.stringify(this.favourites)) {
            this.favourites = currentFavourites
            this.mergeFavourites() // Â¶ÇÊûúÂèëÁîüÂèòÂåñÔºåÈáçÊñ∞ÂêàÂπ∂Êî∂ËóèË∑ØÁ∫ø
            this.refresh() // Ëß¶ÂèëÂà∑Êñ∞
        }
        this.requestLocation()
        this.setupTimers()
    },
    deactivated() {
        this.clearTimers()
    },
    beforeUnmount() {
        this.clearTimers()
    },
    methods: {
        requestLocation() {
            console.log("requestLocation Ë¢´Ë∞ÉÁî®‰∫Ü")
            if (navigator.geolocation) {
                console.log("navigator.geolocation Â≠òÂú®")
                navigator.geolocation.getCurrentPosition(
                    position => {
                        console.log("ÊàêÂäüËé∑ÂèñÁî®Êà∑‰ΩçÁΩÆ", position)
                        const userLat = position.coords.latitude
                        const userLng = position.coords.longitude
                        this.findNearestStopForAllRoutes(userLat, userLng)
                        this.isLocationLoaded = true // ÊàêÂäüËé∑Âèñ‰ΩçÁΩÆÂêéÊ†áËÆ∞‰∏∫true
                        if (!this.locationTimer) {
                            console.log("locationTimer setting")
                            this.setupLocationTimer() // ÂºÄÂßãÂÆöÊúüÂà∑Êñ∞‰ΩçÁΩÆ
                        }
                    },
                    error => {
                        console.error("Êó†Ê≥ïËé∑ÂèñÁî®Êà∑‰ΩçÁΩÆ", error)
                    }
                )
            } else {
                console.error("ÊµèËßàÂô®‰∏çÊîØÊåÅÂú∞ÁêÜ‰ΩçÁΩÆËé∑Âèñ")
            }
        },
        findNearestStopForAllRoutes(userLat, userLng) {
            const favouriteRoutes = this.mergedFavourites // ‰ΩøÁî® mergedFavourites
            const allRoutes = JSON.parse(localStorage.getItem('stored_data_routes')) || {}

            // ÂØπÊØèÊù°Ë∑ØÁ∫øÊü•ÊâæÊúÄËøëËΩ¶Á´ô
            favouriteRoutes.forEach(route => {
                route.directions.forEach(direction => {
                    this.findNearestStopForDirection(route, direction, allRoutes, userLat, userLng)
                })
            })
        },
        findNearestStopForDirection(route, direction, allRoutes, userLat, userLng) {
            const routeData = allRoutes.lineinfos.find(line => line.roadid === direction.routeid && line.roadstatus === direction.dir)
            if (routeData) {
                let nearestStop = null
                let minDistance = Infinity
                routeData.busstation.forEach(station => {
                    const { lat, lng } = this.parseLatLng(station.lng, station.lat)
                    // console.log("üö© ~ findNearestStopForDirection ~ lat, lng üëá\n", station, lat, lng)
                    const distance = this.calculateDistance(userLat, userLng, parseFloat(lat), parseFloat(lng))
                    if (distance < minDistance) {
                        minDistance = distance
                        nearestStop = {
                            routeName: route.routename,
                            stationName: station.stationname,
                            stationNo: station.stationno,
                            distance: distance.toFixed(2),
                            direction: direction.dir
                        }
                    }
                })
                // Â∞ÜÊúÄËøëÁöÑËΩ¶Á´ôÂ≠òÂÇ®Âà∞ direction ÂØπË±°‰∏≠
                direction.nearestStop = nearestStop
            }
        },
        calculateDistance(lat1, lng1, lat2, lng2) {
            const toRad = (value) => (value * Math.PI) / 180
            const R = 6371 // Âú∞ÁêÉÂçäÂæÑÔºåÂçï‰ΩçÔºöÂÖ¨Èáå
            const dLat = toRad(lat2 - lat1)
            const dLng = toRad(lng2 - lng1)
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2)
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
            const distance = R * c // Ë∑ùÁ¶ªÔºåÂçï‰ΩçÔºöÂÖ¨Èáå
            return distance
        },
        parseLatLng(lngStr, latStr) {
            let lng = parseFloat(lngStr.slice(1)) / 100
            let lngDegrees = Math.floor(lng)
            let lngMinutes = (lng - lngDegrees) * 100 / 60
            let lngFinal = lngDegrees + lngMinutes
            if (!lngStr.startsWith("E")) {
                lngFinal = -lngFinal
            }

            let lat = parseFloat(latStr.slice(1)) / 100
            let latDegrees = Math.floor(lat)
            let latMinutes = (lat - latDegrees) * 100 / 60
            let latFinal = latDegrees + latMinutes
            if (!latStr.startsWith("N")) {
                latFinal = -latFinal
            }
            return {
                lng: lngFinal.toFixed(6),
                lat: latFinal.toFixed(6)
            }
        },
        setupTimers() {
            // ‰∏∫ÊØè‰∏™ÂêàÂπ∂ÂêéÁöÑË∑ØÁ∫øËÆæÁΩÆÂÆöÊó∂Âà∑Êñ∞
            this.mergedFavourites.forEach((fav, index) => {
                // ÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÊúâËá™Â∑±ÁöÑÂÆöÊó∂Âô®ÔºåÊØèÈöî 8 ÁßíË∞ÉÁî®‰∏ÄÊ¨°Âà∑Êñ∞
                const timer = setInterval(() => {
                    this.refreshSingleRoute(fav.routeid)
                }, 8000)
                this.timers.push(timer) // Â∞ÜÂÆöÊó∂Âô®‰øùÂ≠òÂà∞ timers Êï∞ÁªÑ‰∏≠
            })
        },
        setupLocationTimer() {
            this.locationTimer = setInterval(() => {
                this.requestLocation()
            }, 5000)
        },
        clearTimers() {
            this.timers.forEach(timer => clearInterval(timer))
            this.timers = []
            if (this.locationTimer) {
                clearInterval(this.locationTimer) // Ê∏ÖÈô§‰ΩçÁΩÆÂà∑Êñ∞ÂÆöÊó∂Âô®
                this.locationTimer = null
            }
        },
        mergeFavourites() {
            const grouped = {}
            this.favourites.forEach(fav => {
                if (!grouped[fav.routeid]) {
                    grouped[fav.routeid] = {
                        routename: fav.routename,
                        routeid: fav.routeid,
                        directions: [],
                        status: fav.status || [],
                        isLoaded: false,
                        isRefreshing: false, // Êñ∞Â¢ûÔºöÊòØÂê¶Ê≠£Âú®Âà∑Êñ∞
                        isError: false, // Êñ∞Â¢ûÔºöÊòØÂê¶Âá∫Áé∞ÈîôËØØ
                        refreshTimer: null
                    }
                }
                grouped[fav.routeid].directions.push({
                    routeid: fav.routeid,
                    dir: fav.dir,
                    laststation: fav.laststation,
                })
            })
            this.mergedFavourites = Object.values(grouped)
        },
        hasActiveBuses(statusList, dir) {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ¨‰∫§Âú®ÂΩìÂâçÊñπÂêëË°åÈ©∂
            return statusList.some(bus => bus.roadstatus === dir)
        },
        goToRouteDetail(route) {
            // Ê†πÊçÆÊî∂ËóèÁöÑÁ∫øË∑ØË∑≥ËΩ¨Âà∞Á∫øË∑ØËØ¶ÊÉÖÈ°µÈù¢
            this.$router.push({ path: '/routedetail', query: { id: route.routeid, dir: route.dir } })
        },
        async refreshSingleRoute(routeid) {
            const fav = this.mergedFavourites.find(f => f.routeid === routeid)
            if (fav) {
                fav.isRefreshing = true // ÂºÄÂßãÂà∑Êñ∞
                try {
                    const res = await getBusLiveStatus({ routeid: fav.routeid })
                    const updatedStatus = res.businfos.filter(bus => bus.lastOutSiteMileage != "0")
                    updatedStatus.sort((a, b) => Number(a.stationno) - Number(b.stationno))
                    fav.status = updatedStatus
                    fav.isError = false // ÊàêÂäüÂêéÊ∏ÖÈô§ÈîôËØØÊ†áËÆ∞
                } catch (error) {
                    console.error(`Ëé∑ÂèñË∑ØÁ∫ø ${routeid} Áä∂ÊÄÅÂ§±Ë¥•`, error)
                    fav.isError = true // Âá∫Áé∞ÈîôËØØ
                } finally {
                    fav.isLoaded = true
                    fav.isRefreshing = false // Âà∑Êñ∞ÂÆåÊàê
                }
            }
        },
        async refresh() {
            this.isRefreshing = true
            let errorOccurred = false
            for (let i = 0; i < this.mergedFavourites.length; i++) {
                const fav = this.mergedFavourites[i]
                fav.isRefreshing = true // ÂºÄÂßãÂà∑Êñ∞
                try {
                    if (this.firstLoad) {
                        fav.isLoaded = false
                    }
                    const res = await getBusLiveStatus({ routeid: fav.routeid })
                    const updatedStatus = res.businfos.filter(bus => bus.lastOutSiteMileage != "0")
                    updatedStatus.sort((a, b) => Number(a.stationno) - Number(b.stationno))
                    fav.status = updatedStatus
                    fav.isError = false
                } catch (error) {
                    console.error(`Ëé∑ÂèñË∑ØÁ∫ø ${fav.routename} Áä∂ÊÄÅÂ§±Ë¥•`, error)
                    fav.isError = true
                    errorOccurred = true
                } finally {
                    fav.isLoaded = true
                    fav.isRefreshing = false // Âà∑Êñ∞ÂÆåÊàê
                }
            }
            this.hasError = errorOccurred
            this.firstLoad = false
            this.isRefreshing = false
        },

        fixNo(e) {
            const num = Number(e)
            if (isNaN(num)) {
                return "N/A"
            }
            return num + 1
        },
        fixSpeed(e) {
            const num = Number(e)
            if (isNaN(num)) {
                return "N/A"
            }
            return (num / 10).toFixed(1)
        }
    }
}
</script>
